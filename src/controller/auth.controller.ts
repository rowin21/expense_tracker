import { Request, Response, NextFunction } from 'express';

import jwt, { SignOptions, JwtPayload } from 'jsonwebtoken';
import { OtpModel } from '../db/models/otp.model';
import { UserModel } from '../db/models/user.model';
import { AccessTokenModel } from '../db/models/accessToken.model';
import { RefreshTokenModel } from '../db/models/refreshToken.model';
import { sendOTP as sendWhatsAppOTP } from '../service/whatsapp.service';
import { config } from '../config';
import { logger } from '../utils/logger';

// /**
//  * @swagger
//  * /auth/send-otp:
//  *   post:
//  *     summary: Send an OTP to the user's phone via WhatsApp
//  *     tags: [Auth]
//  *     requestBody:
//  *       required: true
//  *       content:
//  *         application/json:
//  *           schema:
//  *             type: object
//  *             required:
//  *               - countryCode
//  *               - phone
//  *             properties:
//  *               countryCode:
//  *                 type: string
//  *                 example: "91"
//  *                 description: Country code without the + symbol
//  *               phone:
//  *                 type: string
//  *                 example: "9876543210"
//  *                 description: Phone number without country code
//  *     responses:
//  *       200:
//  *         description: OTP sent successfully
//  *         content:
//  *           application/json:
//  *             schema:
//  *               type: object
//  *               properties:
//  *                 success:
//  *                   type: boolean
//  *                   example: true
//  *                 message:
//  *                   type: string
//  *                   example: "OTP sent successfully"
//  *                 messageID:
//  *                   type: string
//  *                   example: "wamid.xxx"
//  *       400:
//  *         description: Bad request - validation error or rate limit
//  *       500:
//  *         description: Internal server error
//  */
export const sendOTP = async (
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    const { countryCode, phone } = req.body;

    // Check if user exists and is deleted (for login scenario)
    const existingUser = await UserModel.findOne({ countryCode, phone });
    if (existingUser && existingUser.isDeleted) {
      req.apiStatus = {
        isSuccess: false,
        statusCode: 400,
        message: 'User account has been deleted',
      };
      return next();
    }

    // Check for existing OTP to prevent spam (rate limiting)
    const existingOtp = await OtpModel.findOne({ countryCode, phone });
    if (existingOtp) {
      const timeSinceCreation =
        Date.now() - new Date(existingOtp.createdAt).getTime();
      const waitTimeSeconds = 30;

      if (timeSinceCreation < waitTimeSeconds * 1000) {
        const remainingTime = Math.ceil(
          (waitTimeSeconds * 1000 - timeSinceCreation) / 1000,
        );
        req.apiStatus = {
          isSuccess: false,
          statusCode: 400,
          message: `Please wait ${remainingTime} seconds before requesting a new OTP`,
        };
        return next();
      }

      // Delete old OTP if wait time has passed
      await OtpModel.deleteOne({ countryCode, phone });
    }

    // Create new OTP record (OTP will be auto-generated by pre-save hook)
    const newOtp = new OtpModel({
      countryCode,
      phone,
    });
    await newOtp.save();

    // Send OTP via WhatsApp
    const whatsappResult = await sendWhatsAppOTP(
      phone,
      countryCode,
      newOtp.otp,
    );

    if (!whatsappResult.success) {
      logger.error(
        { countryCode, phone },
        'Failed to send OTP via WhatsApp, but OTP was created',
      );
      // In development, we might still want to proceed
      if (config.nodeEnv === 'development') {
        req.apiStatus = {
          isSuccess: true,
          statusCode: 200,
          message: 'OTP created (WhatsApp send failed - dev mode)',
          data: {
            messageID: whatsappResult.messageID,
            devOtp: newOtp.otp, // Only in development
          },
        };
        return next();
      }

      req.apiStatus = {
        isSuccess: false,
        statusCode: 500,
        message: 'Failed to send OTP. Please try again.',
      };
      return next();
    }

    req.apiStatus = {
      isSuccess: true,
      statusCode: 200,
      message: 'OTP sent successfully',
      data: {
        messageID: whatsappResult.messageID,
        ...(config.nodeEnv === 'development' && { devOtp: newOtp.otp }),
      },
    };
    return next();
  } catch (error) {
    logger.error({ error }, 'Error in sendOTP controller');
    req.apiStatus = {
      isSuccess: false,
      statusCode: 500,
      message: 'Internal server error',
    };
    return next();
  }
};

// /**
//  * @swagger
//  * /auth/verify-otp:
//  *   post:
//  *     summary: Verify OTP and login/register user
//  *     tags: [Auth]
//  *     requestBody:
//  *       required: true
//  *       content:
//  *         application/json:
//  *           schema:
//  *             type: object
//  *             required:
//  *               - countryCode
//  *               - phone
//  *               - otp
//  *             properties:
//  *               countryCode:
//  *                 type: string
//  *                 example: "91"
//  *                 description: Country code without the + symbol
//  *               phone:
//  *                 type: string
//  *                 example: "9876543210"
//  *                 description: Phone number without country code
//  *               otp:
//  *                 type: string
//  *                 example: "123456"
//  *                 description: 6-digit OTP received via WhatsApp
//  *     responses:
//  *       200:
//  *         description: OTP verified successfully, user logged in
//  *         content:
//  *           application/json:
//  *             schema:
//  *               type: object
//  *               properties:
//  *                 success:
//  *                   type: boolean
//  *                   example: true
//  *                 message:
//  *                   type: string
//  *                   example: "Login successful"
//  *                 data:
//  *                   type: object
//  *                   properties:
//  *                     accessToken:
//  *                       type: string
//  *                     refreshToken:
//  *                       type: string
//  *                     user:
//  *                       type: object
//  *                       properties:
//  *                         id:
//  *                           type: string
//  *                         phone:
//  *                           type: string
//  *                         countryCode:
//  *                           type: string
//  *                         profileCompleted:
//  *                           type: boolean
//  *                     isNewUser:
//  *                       type: boolean
//  *       400:
//  *         description: Invalid OTP or OTP expired
//  *       500:
//  *         description: Internal server error
//  */
export const verifyOTP = async (
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    const { countryCode, phone, otp } = req.body;

    // Find OTP record
    const otpRecord = await OtpModel.findOne({
      countryCode,
      phone,
      otp,
      isVerified: false,
    });

    if (!otpRecord) {
      req.apiStatus = {
        isSuccess: false,
        statusCode: 400,
        message: 'Invalid or expired OTP',
      };
      return next();
    }

    // Delete used OTP
    await OtpModel.deleteOne({ _id: otpRecord._id });

    // Find or create user
    let user = await UserModel.findOne({ countryCode, phone });
    let isNewUser = false;

    if (!user) {
      user = new UserModel({
        countryCode,
        phone,
        profileCompleted: false,
      });
      await user.save();
      isNewUser = true;
    }

    // Generate JWT tokens
    const accessTokenPayload = {
      userId: user._id,
      phone: user.phone,
      countryCode: user.countryCode,
      role: 'user',
    };

    const accessToken = jwt.sign(accessTokenPayload, config.jwtAccessSecret, {
      expiresIn: config.jwtAccessExpiry,
    } as SignOptions);

    const refreshToken = jwt.sign(accessTokenPayload, config.jwtRefreshSecret, {
      expiresIn: config.jwtRefreshExpiry,
    } as SignOptions);

    // Store tokens in database
    const accessTokenDoc = new AccessTokenModel({
      token: accessToken,
      userId: user._id,
      role: 'user',
    });
    await accessTokenDoc.save();

    const refreshTokenDoc = new RefreshTokenModel({
      token: refreshToken,
      userId: user._id,
      role: 'user',
    });
    await refreshTokenDoc.save();

    req.apiStatus = {
      isSuccess: true,
      statusCode: 200,
      message: isNewUser ? 'Registration successful' : 'Login successful',
      data: {
        accessToken,
        refreshToken,
        user: {
          id: user._id,
          phone: user.phone,
          countryCode: user.countryCode,
          name: user.name,
          email: user.email,
          profileCompleted: user.profileCompleted,
        },
        isNewUser,
      },
      toastMessage: isNewUser ? 'Welcome!' : 'Welcome back!',
    };
    return next();
  } catch (error) {
    logger.error({ error }, 'Error in verifyOTP controller');
    req.apiStatus = {
      isSuccess: false,
      statusCode: 500,
      message: 'Internal server error',
    };
    return next();
  }
};

export const refreshAccessToken = async (
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      req.apiStatus = {
        isSuccess: false,
        statusCode: 400,
        message: 'Refresh token is required',
      };
      return next();
    }

    // 1. Verify Refresh Token Signature
    let decoded: JwtPayload;
    try {
      decoded = jwt.verify(refreshToken, config.jwtRefreshSecret) as JwtPayload;
    } catch (err) {
      logger.error({ err }, 'Invalid refresh token signature');
      req.apiStatus = {
        isSuccess: false,
        statusCode: 401,
        message: 'Invalid refresh token',
      };
      return next();
    }

    // 2. Check if Refresh Token exists in DB (whitelist/validity check)
    const storedToken = await RefreshTokenModel.findOne({
      token: refreshToken,
    });
    if (!storedToken) {
      req.apiStatus = {
        isSuccess: false,
        statusCode: 401,
        message: 'Refresh token not found or revoked',
      };
      return next();
    }

    // 3. Find User
    const user = await UserModel.findById(decoded.userId);
    if (!user) {
      req.apiStatus = {
        isSuccess: false,
        statusCode: 404,
        message: 'User not found',
      };
      return next();
    }

    // 4. Generate New Access Token
    const accessTokenPayload = {
      userId: user._id,
      phone: user.phone,
      countryCode: user.countryCode,
      role: 'user',
    };

    const newAccessToken = jwt.sign(
      accessTokenPayload,
      config.jwtAccessSecret,
      {
        expiresIn: config.jwtAccessExpiry,
      } as SignOptions,
    );

    // 5. Store New Access Token
    await AccessTokenModel.create({
      token: newAccessToken,
      userId: user._id,
      role: 'user',
    });

    req.apiStatus = {
      isSuccess: true,
      statusCode: 200,
      message: 'Access token refreshed successfully',
      data: {
        accessToken: newAccessToken,
      },
    };
    return next();
  } catch (error) {
    logger.error({ error }, 'Error refreshing access token');
    req.apiStatus = {
      isSuccess: false,
      statusCode: 500,
      message: 'Internal server error',
    };
    return next();
  }
};

export const logout = async (
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      req.apiStatus = {
        isSuccess: false,
        statusCode: 400,
        message: 'No token provided',
      };
      return next();
    }

    const token = authHeader.split(' ')[1];

    // Delete the access token from the database
    await AccessTokenModel.deleteOne({ token });

    // Also remove the refresh token for this user to ensure full logout
    if (req.user) {
      await RefreshTokenModel.deleteMany({ userId: req.user._id });
    }

    req.apiStatus = {
      isSuccess: true,
      statusCode: 200,
      message: 'Logged out successfully',
    };
    return next();
  } catch (error) {
    logger.error({ error }, 'Error in logout controller');
    req.apiStatus = {
      isSuccess: false,
      statusCode: 500,
      message: 'Internal server error',
    };
    return next();
  }
};
